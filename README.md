## ТЗ: CRM для учета ремонта автомобилей

- **Технологический стек**: NestJS (API и сервисы синхронизации), React + TypeScript (PWA), PostgreSQL, Docker Compose, Nginx reverse proxy, IndexedDB (или аналог для офлайн-кэша).
- **Деплой**: контейнеры для фронтенда и бэкенда; Nginx проксирует `/api` на Nest-сервис, остальное — на статический бандл React. CI собирает Docker-образы, прогоняет миграции (TypeORM или Prisma).

### Общее описание
- CRM позволяет вести базу клиентов, автомобилей и ремонтов, учитывать запчасти, формировать отчеты по прибыли/затратам.
- Продукт рассчитан на одного пользователя (механика), поэтому интерфейс и бэкенд оптимизированы под персональную работу без системы авторизации.
- **PWA + офлайн-first**: приложение работает без сети, хранит изменения локально и синхронизирует при восстановлении связи. IndexedDB (Dexie.js/idb) — основной слой, возможно расширение до SQLite (sql.js) при сложных запросах.
- **Бухгалтерия**: API предоставляет сводки по выручке, себестоимости и марже за день/неделю/месяц/произвольный диапазон, с экспортом.

### Архитектура данных (PostgreSQL)
- `clients` — клиенты автосервиса:
  - `id` — UUID клиента
  - `full_name` — ФИО
  - `phone` — телефон
  - `email` — email
  - `address` — адрес
  - `notes` — примечания
  - `created_at` — дата создания (UTC)
  - `updated_at` — дата обновления (UTC)
- `vehicles` — автомобили клиента:
  - `id` — UUID авто
  - `client_id` — внешний ключ на `clients.id`
  - `make` — марка
  - `model` — модель
  - `year` — год выпуска
  - `plate_number` — госномер
  - `vin` — VIN
  - `engine` — двигатель (тип/объем)
  - `transmission` — коробка передач
  - `color` — цвет
  - `notes` — примечания
  - `created_at` — дата создания (UTC)
  - `updated_at` — дата обновления (UTC)
- `repairs` — заказы-наряды/ремонты:
  - `id` — UUID ремонта
  - `vehicle_id` — внешний ключ на `vehicles.id`
  - `reported_at` — дата обращения/ремонта
  - `name` — название работы
  - `mileage` — пробег на момент приема
  - `status` — статус ремонта (`draft|in_progress|done|cancelled`)
  - `labor_total` — сумма работ (в рублях, рассчитывается автоматически из `repair_tasks`)
  - `parts_total` — сумма запчастей (продажная, в рублях, рассчитывается автоматически из `parts`)
  - `grand_total` — общий итог (в рублях, рассчитывается автоматически)
  - `comments` — комментарии
  - `synced_at` — время последней синхронизации
  - `created_at` — дата создания (UTC)
  - `updated_at` — дата обновления (UTC)
- `repair_tasks` — выполненные работы в рамках ремонта:
  - `id` — UUID работы
  - `repair_id` — внешний ключ на `repairs.id`
  - `name` — наименование работы
  - `price` — цена работы (в рублях)
  - `created_at` — дата создания (UTC)
  - `updated_at` — дата обновления (UTC)
- `parts` — запчасти, списанные на ремонт:
  - `id` — UUID позиции
  - `repair_id` — внешний ключ на `repairs.id`
  - `name` — наименование запчасти
  - `sku` — артикул/штрихкод
  - `purchase_price` — закупочная цена (в рублях)
  - `sale_price` — продажная цена (в рублях)
  - `quantity` — количество
  - `supplier` — поставщик
  - `created_at` — дата создания (UTC)
  - `updated_at` — дата обновления (UTC)
- `accounting_snapshots` (опционально) — агрегаты для отчетности:
  - `id` — UUID снимка
  - `period_start` — начало периода
  - `period_end` — конец периода
  - `revenue` — выручка (в рублях)
  - `cost` — себестоимость (в рублях)
  - `margin` — маржа (в рублях)
  - `generated_at` — дата формирования снимка (UTC)
- `calendar_events` — события/заметки календаря с напоминаниями:
  - `id` — UUID события
  - `title` — заголовок события
  - `description` — описание/заметка
  - `event_date` — дата и время события (UTC)
  - `reminder_at` — время напоминания (UTC, может быть раньше event_date)
  - `is_completed` — флаг выполнения
  - `color` — цвет для визуализации (hex)
  - `related_repair_id` — опциональная связь с ремонтом
  - `related_client_id` — опциональная связь с клиентом
  - `created_at` — дата создания (UTC)
  - `updated_at` — дата обновления (UTC)
- `push_subscriptions` — подписки на Web Push уведомления:
  - `id` — UUID подписки
  - `endpoint` — URL эндпоинта push-сервиса
  - `p256dh` — ключ для шифрования
  - `auth` — ключ аутентификации
  - `created_at` — дата создания (UTC)

Индексы по внешним ключам, VIN, госномеру, телефону клиента. При необходимости — soft-delete и история изменений (`repairs_history`).

### Основные модули API (NestJS)
- `UserSettingsModule`: хранение локальных предпочтений механика (темы, единицы измерения, параметры синхронизации).
- `ClientsModule`, `VehiclesModule`, `RepairsModule`, `PartsModule`: CRUD, поиск, пагинация, валидация DTO, параметр `updated_since` для инкрементальной синхронизации.
- `AccountingModule`: эндпоинты `/reports/summary?from&to`, `/reports/daily`, `/reports/weekly`, экспорт CSV/PDF.
- `SyncModule`: прием батчей офлайн-мутаций, выдача серверных ID, обработка конфликтов (last-write-wins + журнал).
- `CalendarModule`: управление событиями календаря, заметками с напоминаниями, фильтрация по датам и связанным сущностям (ремонты, клиенты).
- `NotificationsModule`: Web Push уведомления для напоминаний о событиях календаря, управление подписками, фоновый процесс отправки уведомлений по расписанию.

### Фронтенд (React PWA)
- Service Worker (Workbox) кеширует shell, статику и фоновые задачи синка.
- Хранилище: React Query + персист в IndexedDB, отдельные store `clients`, `vehicles`, `repairs`, `tasks`, `parts`, `calendarEvents`, `pendingMutations`.
- Основные экраны:
  1. Дэшборд с KPI (открытые ремонты, выручка, статус синка, ближайшие события).
  2. Клиенты: список, детали, связанные авто.
  3. Карточка автомобиля: история ремонтов, быстрые действия.
  4. Окно ремонта: данные, список работ, запчасти, расчёт итогов.
  5. Запчасти по ремонту: добавление, инвентаризация, маржинальность.
  6. Календарь: месячный/недельный/дневной вид, создание событий с напоминаниями, связь с ремонтами и клиентами, фильтры.
  7. Отчёты: фильтры по периоду, графики, экспорт.
  8. Центр синхронизации: очередь изменений, конфликты, статус.
- Формы: React Hook Form + Zod. UI-библиотека на выбор (MUI, Ant, Chakra).
- Push-уведомления: регистрация подписки через Web Push API, получение напоминаний о событиях календаря даже при закрытом приложении.

### Офлайн-стратегия
- IndexedDB как основное хранилище данных и очереди мутаций.
- Service Worker регистрирует Background Sync; при появлении сети отправляет батч `/sync`, получает подтверждения и обновлённые записи.
- Конфликты: сравнение `updated_at`; при расхождениях сервер возвращает payload, клиент показывает дифф и предлагает выбрать версию или объединить поля.
- Возможность подключения `sql.js` для расширенной аналитики офлайн, но базово достаточно IndexedDB.
- Мониторинг сети: слушатели `online/offline`, периодические `health-check` запросы к `/api/ping` и статус очереди синка (успешные/неудачные `fetch`) отображают пользователю текущее состояние связи и время последнего успешного соединения.

### Use-cases
1. **Добавление клиента и авто офлайн**: пользователь вносит данные, приложение сохраняет в IndexedDB, помечает «Ожидает синхронизации», при появлении сети данные отправляются на сервер и получают окончательные ID.
2. **Создание заказа-наряда**: выбор автомобиля, ввод пробега, статуса, списка работ и запчастей; система считает итоги и формирует предварительный счет.
3. **Учёт запчастей и маржинальности**: добавление позиций с закупочной/продажной ценой, отображение прибыли по ремонту и в целом.
4. **Создание события в календаре**: пользователь добавляет заметку с датой и временем, устанавливает напоминание, опционально связывает с ремонтом или клиентом; система сохраняет событие локально и синхронизирует при наличии сети.
5. **Получение напоминания**: при наступлении времени напоминания (`reminderAt`) сервер отправляет push-уведомление на все активные подписки; пользователь получает уведомление даже при закрытом приложении.
6. **Формирование отчёта**: выбор периода (день/неделя/месяц/кастом), получение агрегированных данных по выручке, себестоимости и марже, возможность выгрузить результат.
7. **Разрешение конфликтов синхронизации**: если записи изменялись на разных устройствах, пользователь видит различия и принимает решение; система ведёт аудит.
8. **Мониторинг дэшборда**: при запуске приложение показывает KPI, ближайшие события календаря и предупреждает о несинхронизированных данных.

### Безопасность и доступ
- Приложение однопользовательское: механик авторизуется один раз локально, серверные эндпоинты защищены фиксированным сервисным ключом или IP-фильтром.
- Локальные данные шифруются (например, IndexedDB + WebCrypto), резервные копии шифруются перед выгрузкой.
- Таблицы аудита и триггеры фиксируют изменения (`repairs_history`) для восстановления истории.

### DevOps и качество
- Конфигурация через `.env`, Nest Config Module с валидацией.
- Docker Compose: сервисы `api`, `web`, `db`, `nginx`.
- Миграции — `typeorm migration` или `prisma migrate`.
- Тесты: backend (Jest unit + e2e), frontend (Vitest/RTL), отдельные тесты логики синхронизации.
- CI: lint, тесты, build, docker build/push, деплой, автозапуск миграций.

### Возможные улучшения
- SMS/email-уведомления о плановом ТО или готовности авто.
- Загрузка фото/документов к ремонту.
- Поддержка нескольких филиалов (tenant_id).
- Интеграция с бухгалтерскими системами (1С, Моё дело) через экспорт или API.

Этот README служит техническим заданием: описывает архитектуру, сущности, API, UX, офлайн-возможности и направления развития CRM для автосервиса.

